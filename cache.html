<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Memory &amp; Caches</title>

    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css">

    <style>
        .box {
            text-anchor: middle;
            font: bold 26px Serif;
            fill: white;
        }

        .mux, .set, .tag {
            stroke-width: 2px;
            stroke: white;
            fill: none;
        }

        .mux-box {
            stroke-width: 2px;
            stroke: white;
        }

        path {
            stroke-linejoin: round;
        }

        .way {
            fill: none;
        }

        .highlight rect.way {
            fill: darkcyan;
        }

        text.mux {
            stroke: none;
            text-anchor: middle;
            font: bold 26px Serif;
            fill: white;
            alignment-baseline: center;
        }

        text.comparator {
            stroke: none;
            text-anchor: middle;
            font: bold 16px Serif;
            fill: white;
            alignment-baseline: center;
        }

    </style>

</head>
<body>
<svg width="0" height="0">
    <defs>
        <marker id='head' orient="auto" markerWidth='3' markerHeight='6' refX='3' refY='3'>
            <path d='M0,0 V6 L3,3 Z' fill="white"/>
        </marker>
    </defs>
</svg>

<script src="d3.v5.min.js"></script>
<script>
    let doc = {
        highlightedSet: -1,
        setPartHighlighted: false,
        tagPartHighlighted: false,
        muxTagHighlighted: false,
        dataTagHighlighted: false,
        wayOrHighlight: -1,
        wayCompHighlight: -1
    };

    const numSets = 4;
    const numWays = 6;

    const trans = d3.transition().duration(300);

    const width = 1200, height = 800;
    const svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", `translate(${width / 2}, 0)`);
    const boxWidth = 150;
    const boxHeight = 40;

    function box(name, colour, x, y) {
        const box = svg.append("g")
            .attr("transform", `translate(${x}, ${y})`);
        box.append("rect")
            .attr("width", boxWidth)
            .attr("height", boxHeight)
            .attr("fill", colour)
            .attr("stroke-width", "2")
            .attr("stroke", "white");
        box.append("text")
            .attr("x", boxWidth / 2)
            .attr("y", boxHeight / 2)
            .attr("dy", "0.35em")
            .attr("class", "box")
            .text(name);
        return box;
    }

    const muxWidth = 200;
    const muxInTop = 30;
    const muxHeight = 40;
    const muxLineHeight = 25;
    const setWidth = muxWidth / numSets;
    // noinspection JSSuspiciousNameCombination
    const setHeight = setWidth;

    function updateSets(root, hlFill) {
        const setData = [];
        for (let i = 0; i < numSets; ++i)
            setData[i] = {
                highlight: i === doc.highlightedSet,
                ways: Array(numWays).fill(i === doc.highlightedSet)
            };
        const sets = root.selectAll('.set')
            .data(setData);
        const lines = sets.enter()
            .append("g")
            .attr("class", "set")
            .attr("transform", (d, i) => `translate(${setWidth * i}, ${muxHeight})`)
            .append("line")
            .attr("x1", setWidth / 2)
            .attr("x2", setWidth / 2)
            .attr("y1", 0)
            .attr("y2", muxLineHeight)
            .attr('marker-end', 'url(#head)');
        lines.merge(sets.select('line'))
            .transition(trans)
            .attr('stroke', d => d.highlight ? 'darkcyan' : 'white')
            .attr('stroke-width', d => d.highlight ? 4 : 2);
        sets.exit().remove();

        const ways = sets
            .selectAll("rect")
            .data((d) => d.ways);
        ways.exit().remove();

        const rects = ways.enter()
            .append("rect")
            .attr("class", "way")
            .attr("y", (d, i) => muxLineHeight + i * setHeight)
            .attr("width", setWidth)
            .attr("height", setHeight);
        rects.merge(ways).transition(trans)
            .style('fill', d => d ? hlFill : 'black');
    }

    function muxAndSets(x, y, name) {
        const mux = svg.append("g")
            .attr("transform", `translate(${x}, ${y})`);
        mux.append("path")
            .attr("class", "mux-box")
            .attr("d", `M${muxInTop} 0 l${muxWidth - 2 * muxInTop} 0 l${muxInTop} ${muxHeight} l${-muxWidth} 0 Z`);
        mux.append("text")
            .attr("x", muxWidth / 2)
            .attr("y", muxHeight / 2)
            .attr("class", "mux")
            .attr("dy", "0.35em")
            .text("MUX");
        mux.append("text")
            .attr("x", muxWidth / 2)
            .attr("y", muxHeight / 2 + muxLineHeight + (numWays + 1) * setHeight)
            .attr("class", "mux")
            .attr("dy", "0.35em")
            .text(name);

        updateSets(mux, "black"); // TODO why needed
        return mux;
    }

    const allBoxWidth = 3 * boxWidth;
    const tag = box("Tag", "darkred", -allBoxWidth / 2, 0);
    const set = box("Set", "darkcyan", -allBoxWidth / 2 + boxWidth, 0);
    const offset = box("Offset", "green", -allBoxWidth / 2 + boxWidth * 2, 0);

    const muxTop = 100;
    const tagMux = muxAndSets(-width / 2, muxTop, "Tag");
    const dataMux = muxAndSets(width / 2 - muxWidth, muxTop, "Data");

    const setLines = svg.append("g").attr("class", "set");
    const boxToMuxGap = muxTop - boxHeight;
    setLines
        .append("path")
        .attr("d", `M0 ${boxHeight} v ${boxToMuxGap / 2} H${-width / 2 + muxWidth / 2} v${boxToMuxGap / 2}`)
        .attr("marker-end", "url(#head)");
    setLines
        .append("path")
        .attr("d", `M0 ${boxHeight + boxToMuxGap / 2} H${width / 2 - muxWidth / 2} v${boxToMuxGap / 2}`)
        .attr("marker-end", "url(#head)");

    // Comparator and data lines
    const muxEdgeX = -width / 2 + muxWidth;
    const dataEdgeX = width / 2 - muxWidth;
    const gapToFirstElem = 100;
    const allElemSpace = (-muxEdgeX) - gapToFirstElem;
    const comparatorWidth = 80;
    const comparatorHeight = setHeight * 0.8;
    const comparatorOverlap = (allElemSpace - comparatorWidth) / numWays;
    const orGateDown = 15;
    const orGateWidth = 50;
    const orGateHeight = setHeight * 0.5;
    const dataBottom = muxTop + muxHeight + muxLineHeight + (numWays + 1) * setHeight;
    const orGateOverlap = (allElemSpace - orGateWidth) / numWays;
    const orMid = dataEdgeX - gapToFirstElem - orGateWidth - orGateOverlap * numWays / 2;

    const tagStartMidX = -allBoxWidth / 2 + boxWidth / 2;

    const waysRoot = svg.append("g").attr("class", "wayRoot");

    function doWays() {
        const wayConfig = [];
        for (let i = 0; i < numWays; ++i) {
            wayConfig.push({
                comp: i === doc.wayCompHighlight,
                or: i === doc.wayOrHighlight
            });
        }
        const tagComplex = waysRoot.selectAll("g.wayRoot")
            .data(wayConfig);
        tagComplex.exit().remove();
        const merged = tagComplex.enter()
            .append("g").attr("class", "tag wayRoot")
            .each(((d, i, nodes) => {
                const tagCentreY = muxTop + muxHeight + muxLineHeight + i * setHeight + setHeight / 2;
                const compLeft = muxEdgeX + gapToFirstElem + comparatorOverlap * i;
                const tagComplex = d3.select(nodes[i]);
                tagComplex
                    .append("path")
                    .attr("class", "mux-tag")
                    .attr("d", `M${muxEdgeX} ${tagCentreY} H${compLeft}`)
                    .attr("marker-end", "url(#head)");
                tagComplex.append("path")
                    .attr("d", `M${tagStartMidX} ${boxHeight} V${muxTop + muxHeight / 2} H${compLeft + comparatorWidth - 10} V${tagCentreY - comparatorHeight / 2}`)
                    .attr("class", "tag-line")
                    .attr("marker-end", "url(#head)");
                const comparator = tagComplex.append("g")
                    .attr("transform", `translate(${compLeft},${tagCentreY - comparatorHeight / 2})`);
                comparator.append("rect")
                    .attr("class", "comparator")
                    .attr("width", comparatorWidth)
                    .attr("height", comparatorHeight);
                comparator.append("text")
                    .attr("x", comparatorWidth / 2)
                    .attr("y", comparatorHeight / 2)
                    .attr("class", "comparator")
                    .attr("dy", "0.35em")
                    .text("Comp");

                const orLeft = dataEdgeX - gapToFirstElem - orGateWidth - orGateOverlap * i;
                const orGateConnector = 10;
                const orComplex = tagComplex.append("g");
                orComplex.append("path")
                    .attr("class", "data-tag")
                    .attr("d", `M${dataEdgeX} ${tagCentreY} H${orLeft + orGateWidth - orGateConnector} v${orGateDown}`)
                    .attr("marker-end", "url(#head)");
                orComplex.append("path")
                    .attr("class", "comp-to-or")
                    .attr("d", `M${compLeft + comparatorWidth} ${tagCentreY} H${orLeft + orGateConnector} v${orGateDown}`)
                    .attr("marker-end", "url(#head)");
                const orTop = orGateDown + tagCentreY;
                const curveness = orGateHeight / 0.78;
                orComplex.append("path")
                    .attr("d", `M${orLeft} ${orTop} h${orGateWidth} c0 ${curveness} ${-orGateWidth} ${curveness} ${-orGateWidth} 0`)
                    .attr("class", "or-gate");
                orComplex.append("path")
                    .attr("class", "or-gate-out")
                    .attr("d", `M${orLeft + orGateWidth / 2} ${orTop + orGateHeight} V${dataBottom} H${orMid}`);

            }))
            .merge(tagComplex);
        merged.select("rect.comparator")
            .transition(trans)
            .attr("fill", d => d.comp ? "goldenrod" : "black");
        merged.select("path.comp-to-or")
            .transition(trans)
            .attr("stroke-width", d => d.comp ? 4 : 2)
            .attr("stroke", d => d.comp ? "goldenrod" : "white");
        merged.select("path.or-gate")
            .transition(trans)
            .attr("fill", d => d.or ? "purple" : "black");
        merged.select("path.or-gate-out")
            .transition(trans)
            .attr("stroke-width", d => d.or ? 4 : 2)
            .attr("stroke", d => d.or ? "purple" : "white");
    }

    const outputComplex = svg.append("g")
        .append("path")
        .attr("d", `M${orMid} ${dataBottom} v50`)
        .attr("marker-end", "url(#head)");

    function update() {
        updateSets(tagMux, "darkred");
        updateSets(dataMux, "purple");

        setLines.selectAll("path")
            .transition(trans)
            .attr("stroke-width", doc.setPartHighlighted ? 4 : 2)
            .attr("stroke", doc.setPartHighlighted ? "darkcyan" : "white");

        d3.selectAll(".mux-box")
            .transition(trans)
            .attr("fill", doc.setPartHighlighted ? "darkcyan" : "black");

        d3.selectAll("path.tag-line")
            .transition(trans)
            .attr("stroke-width", doc.tagPartHighlighted ? 4 : 2)
            .attr("stroke", doc.tagPartHighlighted ? "darkred" : "white");

        d3.selectAll("path.mux-tag")
            .transition(trans)
            .attr("stroke-width", doc.muxTagHighlighted ? 4 : 2)
            .attr("stroke", doc.muxTagHighlighted ? "darkred" : "white");

        d3.selectAll("path.data-tag")
            .transition(trans)
            .attr("stroke-width", doc.dataTagHighlighted ? 4 : 2)
            .attr("stroke", doc.dataTagHighlighted ? "purple" : "white");

        doWays();

        outputComplex
            .transition(trans)
            .attr("stroke-width", doc.wayOrHighlight >= 0 ? 4 : 2)
            .attr("stroke", doc.wayOrHighlight >= 0 ? "purple" : "white");
    }

    update();

</script>
</body>
</html>
